from custom_errors.errors import *
from pieces.pieces import *
from pprint import pprint

class Board():

    self.new_game_setup = {
                # Black pieces
                'a8':Rook  ('a', 8, 'black'),
                'b8':Knight('b', 8, 'black'),
                'c8':Bishop('c', 8, 'black'),
                'd8':Queen ('d', 8, 'black'),
                'e8':King  ('e', 8, 'black'),
                'f8':Bishop('f', 8, 'black'),
                'g8':Knight('g', 8, 'black'),
                'h8':Rook  ('h', 8, 'black'),
                # Black pawns
                'a7':Pawn('a', 7, 'black'),
                'b7':Pawn('b', 7, 'black'),
                'c7':Pawn('c', 7, 'black'),
                'd7':Pawn('d', 7, 'black'),
                'e7':Pawn('e', 7, 'black'),
                'f7':Pawn('f', 7, 'black'),
                'g7':Pawn('g', 7, 'black'),
                'h7':Pawn('h', 7, 'black'),
                # White pieces
                'a1':Rook  ('a', 1, 'black'),
                'b1':Knight('b', 1, 'black'),
                'c1':Bishop('c', 1, 'black'),
                'd1':Queen ('d', 1, 'black'),
                'e1':King  ('e', 1, 'black'),
                'f1':Bishop('f', 1, 'black'),
                'g1':Knight('g', 1, 'black'),
                'h1':Rook  ('h', 1, 'black'),
                # Black pawns
                'a2':Pawn('a', 2, 'black'),
                'b2':Pawn('b', 2, 'black'),
                'c2':Pawn('c', 2, 'black'),
                'd2':Pawn('d', 2, 'black'),
                'e2':Pawn('e', 2, 'black'),
                'f2':Pawn('f', 2, 'black'),
                'g2':Pawn('g', 2, 'black'),
                'h2':Pawn('h', 2, 'black'), 
    }

    def __init__(self, position = '', new_game = True):
        self.new_game = new_game # Always start a new game with new board
        if self.new_game: objects = self.new_game_setup
        else: objects = self.read(position)
        self.board = self.gen_board()
        initialize_pieces(objects)
    
    def initialize_pieces(self, obj_dict):
        for key in obj_dict: # key = 'a1'
            self.board[key] = obj_dict[key]
        

    def gen_board(self):
        '''
        Generate an empty dictionary that uses coordinates for keys.

        board = {
            'a1':None, 'a2':None, 'a3':None, ..., 'a8':None,
            'b1':None, 'b2':None, 'b3':None, ..., 'b8':None,
            ...
            'h1':None, 'h2':None, 'h3':None, ..., 'h8':None
        }

        '''
        board = {}
        files = [chr(i + 96) for i in range(1, 9)]
        ranks = [_ for _ in range(1, 9)]
        for f in files:
            for r in ranks:
                key = f + str(r)
                board[key] = None
        return board

    def puzzle(self, position = ''):
        if position == '': 
            raise UndefinedGame("You haven't specified a starting position")
        else:
            self.__init__(position = position, new_game = False)

    def read(self, string):
        '''
        Reads the FEN transcript of the starting position
        '''
        '''
        1.Piece placement (from White's perspective). Each rank is described, starting with rank 8 
        and ending with rank 1; within each rank, the contents of each square are described from 
        file "a" through file "h". Following the Standard Algebraic Notation (SAN), each piece is 
        identified by a single letter taken from the standard English names (pawn = "P", knight = "N", 
        bishop = "B", rook = "R", queen = "Q" and king = "K"). White pieces are designated using 
        upper-case letters ("PNBRQK") while black pieces use lowercase ("pnbrqk"). Empty squares 
        are noted using digits 1 through 8 (the number of empty squares), and "/" separates ranks.
        2.Active color. "w" means White moves next, "b" means Black moves next.
        3.Castling availability. If neither side can castle, this is "-". Otherwise, this has one or 
        more letters: "K" (White can castle kingside), "Q" (White can castle queenside), "k" (Black 
        can castle kingside), and/or "q" (Black can castle queenside). A move that temporarily 
        prevents castling does not negate this notation.
        4.En passant target square in algebraic notation. If there's no en passant target square, 
        this is "-". If a pawn has just made a two-square move, this is the position "behind" the 
        pawn. This is recorded regardless of whether there is a pawn in position to make an en passant 
        capture.
        5.Halfmove clock: The number of halfmoves since the last capture or pawn advance, used for 
        the fifty-move rule.[7]
        6.Fullmove number: The number of the full move. It starts at 1, and is incremented after Black's move.
        '''
        example = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        objects = {}
        string = example.split('') 
        return objects

class Engine():

    def start():
        pass

    def save():
        pass

    def end():
        pass

if __name__ == '__main__':

    start = 'Ra8 Nb8 Bc8 Qd8 Ke8 Bf8 Ng8 Rh8 a7 b7 c7 d7 e7 f7 g7 h7 a2 b2 c2 d2 e2 f2 g2 h2 Ra1 Nb1 Bc1 Qd1 Ke1 Bf1 Ng1 Rh1'
    puzzle = 'a2w a3b Bb3w Kd3w e3w h3w Rb4b g4w Ke5b Ra6w Bb6b e6b g6b h6b' # Check the daily puzzle on chess.com

    b = Board(start)
    # pprint (b.board) # It actually worked xD heh kek :D
